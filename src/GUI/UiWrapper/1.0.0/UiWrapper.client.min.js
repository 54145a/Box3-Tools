

// 创建 UiWrapper 代码
// 这两行代码必须放在最顶部！
const UiNodeWrapper = createUiNodeWrapper();
const uiWrapper = new UiNodeWrapper(ui);



// UiWrapper 核心代码
// 下述代码可以放在最后
let uiNodeWrapperIsCreated = false
function createUiNodeWrapper() {
    // 作者：七式草莓
    // 如果需要使用 UiWrapper，请勿删除或修改任何注释！
    const UiNode = ui.constructor;
    class UiNodeWrapper {
        constructor(node) {
            if (!(node instanceof UiNode)) throw new Error("参数 node 类型必须为 UiNode（或其子类）");
            this.node = node;
            if(UiNodeWrapper.nodes.has(this)) throw new Error("请勿重复创建 UiNodeWrapper（出现此错误的常见原因：修改了内部代码，或使用了通过 constructor 属性获取的构造函数创建 UiNodeWrapper）");
            UiNodeWrapper.nodes.set(node, this);
        };
        static version = "1.0.0";
        static createCoord2(offset, scale){
            let coord2 = Coord2.create();
            if(offset) coord2.offset.copy(offset);
            if(scale) coord2.scale.copy(scale);
            return coord2
        };
        static createNode(nodeConstructor){
            if(!nodeConstructor || !nodeConstructor.create) throw new Error("createNode: nodeConstructor 必须是一个有效的可创建UI节点的构造函数");
            return this.get(nodeConstructor.create());
        };
        static nodes = new WeakMap();
        static get(node){
            if(!node) return null;
            if(UiNodeWrapper.nodes.has(node)) return UiNodeWrapper.nodes.get(node);
            return new UiNodeWrapper(node);
        };
        static getUiNode(node) {
            if (node instanceof UiNode) return node;
            if (node instanceof UiNodeWrapper) return node.node;
            throw new Error("在需要传递节点的参数中传递了不是节点的对象！");
        };
        get children(){
            return Array.from(this.node.children).map((node) => UiNodeWrapper.get(node));
        };
        get parent(){
            if(!this.node.parent) return null;
            return UiNodeWrapper.get(this.node);
        };
        set parent(node){
            if(!node) {
                this.node.parent = void 0;
                return;
            }
            this.node.parent = UiNodeWrapper.getUiNode(node);
        }
        get displayed(){
            let currentNode = this.node
            while(currentNode !== ui && currentNode.parent) currentNode = currentNode.parent;
            return currentNode === ui;
        };
        config(key, value, options = "offset"){
            if(["children", "events"].includes(key)) throw new Error(`nodeWrapper.config: 不能设置只读属性 ${key}`);
            if(typeof this.node[key] === "function") throw new Error(`nodeWrapper.config: 不能设置方法 ${key}`);
            let oldValue = this.node[key];
            if(oldValue instanceof Vec2 || oldValue instanceof Vec3) {
                oldValue.copy(value);
            }else if(oldValue instanceof Coord2){
                if(options === "offset" || options === "all") oldValue.offset.copy(value.offset);
                if(options === "scale" || options === "all") oldValue.scale.copy(value.scale);
            }else{
                this.node[key] = value;
            }
            return this;
        };
        eventOn(type, listener){
            this.node.events.on(type, listener);
        };
        createChildNode(nodeConstructor){
            if(!nodeConstructor || !nodeConstructor.create) throw new Error("createNode: nodeConstructor 必须是一个有效的可创建UI节点的构造函数");
            let node = nodeConstructor.create();
            node.parent = this.node;
            return UiNodeWrapper.get(node);
        };
        eventOnce(type, listener){
            this.node.events.once(type, listener);
        };
        appendChild(...childrenNode) {
            childrenNode.forEach((node) => {
                if (!node) return;
                node.node.parent = UiNodeWrapper.getUiNode(this.node);
            });
        };
        replaceChild(targetChild, newChild){
            let targetChildNode = UiNodeWrapper.getUiNode(targetChild);
            let newChildNode = void 0;
            if (newChild) newChildNode = UiNodeWrapper.getUiNode(newChild);
            if (targetChildNode.parent === this.node) targetChildNode.parent = void 0;
            if (newChildNode) newChildNode.parent = this;
        };
        removeChild(...childrenNode){
            childrenNode.forEach((node) => {
                if (!node) return;
                let targetChildNode = UiNodeWrapper.getUiNode(node);
                if (targetChildNode.parent === this.node) targetChildNode.parent = void 0;
            })
        };
        contains(target){
            let targetNode = UiNodeWrapper.get(target);
            let currentNode = targetNode;
            while(currentNode !== this.node && currentNode.parent) currentNode = currentNode.parent;
            return currentNode === this.node;
        };
        findChildByName(name){
            let child = this.node.findChildByName(name);
            if(!child) return null;
            return UiNodeWrapper.get(child);
        };
        clone(){
            return UiNodeWrapper.get(this.node.clone());
        };
    };
    return new Proxy(UiNodeWrapper, {
        construct(target, argArray, newTarget){
            if(argArray[0] instanceof UiNodeWrapper) return UiNodeWrapper;
            if(argArray.length <= 0 || !(argArray[0] instanceof UiNode)) throw new Error("创建 UiNodeWrapper 时需要一个参数 node，并且类型为 UiNode");
            if(target.nodes.has(argArray[0])) return target.nodes.get(argArray[0]);
            return Reflect.construct(target, argArray, newTarget);
        }
    });
}

