
class RemoteGroups {constructor(t) {this.target = Array.isArray(t) ? t : [t];this.listeners = [];};send(m) {remoteChannel.sendClientEvent(this.target, m);};sendOne(e, m) {if (this.target.includes(e)) {remoteChannel.sendClientEvent([e], m)}};each(c) {this.target.forEach(v => c(v, this));};add(e) {this.target.push(e);};cancel(e) {this.target = this.target.filter(v => v !== e);};stop() {this.listeners.forEach(v => v.cancel());this.target = [];this.listeners = [];};_register(f, h) {this.listeners.push(remoteChannel.onServerEvent((a) => {if (this.target.includes(a.entity) && typeof a.args?.id !== "number") h[a.args?.id]?.(a);if (this.target.includes(a.entity)) f(a);}));};}
class RemoteServerWrapper {static quitCode = {"1": "传入的实体/实体组不正确","2": "非服务端"};static events = new Map();static listen(e, t = "data", f, d) {if (!this.events.get(e)) this.events.set(e, []);this.events.get(e).push({ type: t, handler: f, id: d });return {cancel: () => {this.off(e, f);}}};static once(e, t = "data", f, d) {if (!this.events.get(e)) this.events.set(e, []);let handler = function (...args) {this.off(e, f);return f(...args);};this.events.get(e).push({type: t, handler, id: d});return {cancel: () => {this.off(e, handler);}}};static send(t1, message, type = "data", id = Date.now()) {remoteChannel.sendClientEvent([t1], this.wrap(type, message, id));return id;};static emit(t, t2, t3, t4, ...t5) {if (!this.events.get(t)) this.events.set(t, []);this.events.get(t).forEach(v => {if (typeof v.handler === "function" && (!t4 || !v.id || (t4 && t4 === v.id)) && v.type === t2) {if (t2 === "data") v.handler.apply(this, t5);else if (t2 === "communicate") {let res = v.handler.apply(this, t5);if (res.then) res.then(r => t3.sendOne(t, r, "data", t4));else t3.sendOne(t, res, "data", t4);}};});};static off(t1, f) {if (this.events.get(t1)) this.events.set(t1, this.events.get(t1).filter(v => v.handler !== f));};static async timer(f, m) {let v1 = false, v2 = false, v3;try {let v4 = await Promise.race([(async () => { let res = await f(); clearTimeout(v3); v1 = true; return res })(),new Promise((_r, r1) => {v3 = setTimeout(() => {v2 = v1 = true;r1("Timeout");}, m);})]);if (v4 && v1 && !v2) return v4;} catch (err) {if (!v1) throw err;if (v2) return new Error("Timeout");}};constructor(t1) {if ((Array.isArray(t1) && t1.every(v => v instanceof GameEntity)) || t1 instanceof GameEntity) this.client = new RemoteGroups(t1);else throw this._quit("1");try { remoteChannel } catch { throw this._quit("2") };this._start();};onMessage(t1, f) {this.client.target.forEach(v1 => {if (!this.constructor.events.get(v1)) this.constructor.events.set(v1, []);this.constructor.events.get(v1).push({ type: t1, handler: f });});};send(t1, t2 = "data", t3 = Date.now()) {this.client.send(this.wrap(t2, t1, t3));return t3;};sendOne(t1, t2, t3 = "data", t4 = Date.now()) {this.client.sendOne(t1, this.wrap(t3, t2, t4));return t4;};add(t1) {this.client.add(t1);};cancel(t1) {this.client.cancel(t1);this.constructor.events.delete(t1);};stop() {this.client.target.forEach(v => this.constructor.events.delete(v));this.client.stop();};async communicateEntities(t1, t2) {let r = [];this.client.each((t) => {r.push(new Promise(f1 => {if (t && !t.destroyed) {this.constructor.once(t, "data", (v1) => { t2(v1.data); f1(v1.data); }, this.send(t1, "communicate"));}}))});return Promise.all(r);};async communicate(t1, t2, t3) {if (!this.client.target.includes(t1)) return null;return new Promise(resolve => {if (t1 && !t1.destroyed) {this.constructor.once(t1, "data", (args) => { t3(args.data); resolve(args.data); }, this.sendOne(t1, t2, "communicate"))}});};wrap(t1, t2, t3) {return {type: t1,data: t2,id: t3}};_toData(t1) {if (typeof t1 === "object" && t1 !== null) return t1;else return { data: t1 };};_start() {this.client._register(({ entity, args }) => {this.constructor.emit(entity, this._toData(args).type, this, this._toData(args).id, args, entity);},{});};_quit(c) {return new Error(`[Remote Server] ${this.constructor.quitCode[c]}`);};}
